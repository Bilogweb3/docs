---
tags: ["core"]
---

import { Callout } from "nextra/components";

# Entrypoints

Entrypoints are where your contract can be called from the outside world. You
can equate that to your `main` function in C, Rust, Java, etc.  
However, there is one _small_ difference: In CosmWasm, you have multiple of
these entrypoints, each one different from the last.

In this section we want to give you a quick overview over all the entrypoints
and when they are called.

## Defining entrypoints

While you will learn all about entrypoints in the next sections, we want to give
you an idea on how to define an entrypoint in the first place.

CosmWasm defines the handy `#[entry_point]` attribute macro. You simply annotate
a function with it, and it automatically generates code that communicates to the
VM: "Hey! This is an entrypoint, please use it when needed!"

<Callout>
  When defining an entrypoint, it is important to use the correct types for the
  parameters and return type. Incorrect types will cause errors when trying to
  call the contract.
  <br /> In the following sections we will take a look at all possible entrypoints,
  including the correct function signature.
</Callout>

<Callout>
  Even though the sections will show you to use `#[entry_point]`, it is
  recommended to define your endpoints as `#[cfg_attr(not(feature = "library"),
  entry_point)]`.
  <br /> The reason behind that is that it allows you to reuse your contract as a
  library.
</Callout>

```rust template="core"
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: InstantiateMsg,
) -> StdResult<Response> {
    // Do some logic here
    Ok(Response::default())
}
```
