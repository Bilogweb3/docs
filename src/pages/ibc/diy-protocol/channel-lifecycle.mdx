---
tags: ["ibc", "ics4"]
---

import { Callout } from "nextra/components";

# Channel lifecycle

A channel is a connection between two IBC ports that allows them to send packets
to each other. In this section, we will cover how to establish a channel and how
to close it. Since a channel is a connection between two ports, it can connect
two chain modules, two contracts, or a module and a contract.

<Callout>
  For the sake of readability, we will assume that both ends of the channel are
  contracts in the following explanation. For more general information about the
  channel lifecycle, see the [ICS 004 specification] or [IBC channel docs].
</Callout>

Each channel also has an order that can be either `Ordered` or `Unordered`. This
is encoded in the [`IbcOrder`] enum. In an ordered channel, packets must be
processed by the receiving chain in the order in which they were sent. In an
unordered channel, packets are processed in the they arrive.

[`IbcOrder`]:
  https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.IbcOrder.html
[ICS 004 specification]:
  https://github.com/cosmos/ibc/tree/main/spec/core/ics-004-channel-and-packet-semantics#channel-lifecycle-management
[IBC channel docs]: https://ibc.cosmos.network/main/ibc/overview#channels

## Establishing a channel

To send packets between two chains, you need to establish a channel between
them. This process involves two calls per chain. These are described below. Once
the channel is established, you can start sending packets through it, which we
will cover in the next section. To initiate the channel creation, you can use a
relayer binary such as [hermes] to perform the handshake between the two
endpoints. Returning an error from one of the calls will cause the channel
handshake to fail.

<Callout>
  In the following, we will refer to the two chains we want to connect as chain
  A and B. The handshake starts on chain A.
</Callout>

We will take a closer look at the handshake process, but here is a brief summary
of the steps:

1. `ibc_channel_open` on chain A with `IbcChannelOpenMsg::OpenInit`
2. `ibc_channel_open` on chain B with `IbcChannelOpenMsg::OpenTry`
3. `ibc_channel_connect` on chain A with `IbcChannelConnectMsg::OpenAck`
4. `ibc_channel_connect` on chain B with `IbcChannelConnectMsg::OpenConfirm`

[hermes]:
  https://hermes.informal.systems/tutorials/local-chains/add-a-new-relay-path.html#3-channel-identifiers

### Channel open

When the channel creation is started by the relayer, the first call to the
contract is made on chain A. This call is made to the `ibc_channel_open`
entrypoint with the `IbcChannelOpenMsg::OpenInit` variant. Then the same
entrypoint is called on chain B with the `IbcChannelOpenMsg::OpenTry` variant.
See the following example and the [`IbcChannelOpenMsg` documentation].

```rust filename="ibc.rs" template="core"
/// enforces ordering and versioning constraints
#[entry_point]
pub fn ibc_channel_open(
    deps: DepsMut,
    env: Env,
    msg: IbcChannelOpenMsg
) -> StdResult<IbcChannelOpenResponse> {
    let channel = msg.channel();

    // here we should check if the channel is what we expect (e.g. the order)
    if channel.order != IbcOrder::Ordered {
        return Err(StdError::generic_err("only ordered channels are supported"));
    }
    // the OpenTry variant (on chain B) also has the counterparty version
    // we should check if it is what we expect
    if let Some(counter_version) = msg.counterparty_version() {
        if counter_version != IBC_APP_VERSION {
            return Err(StdError::generic_err(format!(
                "Counterparty version must be `{IBC_APP_VERSION}`"
            )));
        }
    }

    // return the channel version we support
    Ok(Some(Ibc3ChannelOpenResponse {
        version: IBC_APP_VERSION.to_string(),
    }))
}

const IBC_APP_VERSION: &str = "my-protocol-v1";
```

In the example above, we return the same version we expect from the
counterparty, but you can return a different version if the counterparty accepts
it. The version is used to ensure that both chains are running the protocol that
the other one expects. You can also return `None` if you just want to accept the
counterparty version.

<Callout>
  Opening a channel is generally a permissionless process, so make sure to keep
  that in mind when implementing the entrypoints. You can add additional checks
  to ensure that the channel is connecting to the correct counterparty or have a
  state item containing a `bool` that is checked here to explicitly disable new
  channels.
</Callout>

[`IbcChannelOpenMsg` documentation]:
  https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.IbcChannelOpenMsg.html

### Channel connect

After the `OpenTry` variant is called on chain B, the relayer calls the
`ibc_channel_connect` entrypoint, first with the `IbcChannelConnectMsg::OpenAck`
variant on chain A, then the `IbcChannelConnectMsg::OpenConfirm` variant on
chain B. The full data this entrypoint receives can be seen in the
[`IbcChannelConnectMsg`] documentation. Here is more example code:

```rust filename="ibc.rs" template="core"
pub fn ibc_channel_connect(
    deps: DepsMut,
    env: Env,
    msg: IbcChannelConnectMsg,
) -> StdResult<IbcBasicResponse> {
    let channel = msg.channel();

    // you probably want to save the `channel.endpoint.channel_id` to storage,
    // so you can use it when sending packets
    // TODO: add storage code above using storey?

    Ok(IbcBasicResponse::new())
}
```

[`IbcChannelConnectMsg`]:
  https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.IbcChannelConnectMsg.html

## Closing a channel

Similarly to opening a channel, closing a channel involves a handshake process.
However, this time the process only involves one call per chain. The relayer
initiates the process by calling the `ibc_channel_close` entrypoint with the
`IbcChannelCloseMsg::CloseInit` variant on chain A, followed by the same
entrypoint with the `IbcChannelCloseMsg::CloseConfirm` on chain B. The full data
can be seen in the [`IbcChannelCloseMsg`] documentation. Here is an example:

```rust filename="ibc.rs" template="core"
#[entry_point]
pub fn ibc_channel_close(
    deps: DepsMut,
    env: Env,
    msg: IbcChannelCloseMsg,
) -> StdResult<IbcBasicResponse> {
    Err(StdError::generic_err("closing not allowed"))
}
```

In this entrypoint, you can handle the closing process as you see fit. This can
involve cleaning up any storage related to the channel or simply returning an
error to prevent the channel from closing.

[`IbcChannelCloseMsg`]:
  https://docs.rs/cosmwasm-std/latest/cosmwasm_std/enum.IbcChannelCloseMsg.html
